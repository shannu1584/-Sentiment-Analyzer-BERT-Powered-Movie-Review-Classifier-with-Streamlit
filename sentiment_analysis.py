# -*- coding: utf-8 -*-
"""sentiment_analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zZdJxiavuiiXAw5JWoR_FPA_pTl9SXni
"""

!pip install transformers datasets torch streamlit pyngrok

import torch
from transformers import BertTokenizer, BertForSequenceClassification, Trainer, TrainingArguments
from datasets import load_dataset
import numpy as np
from sklearn.metrics import accuracy_score, precision_recall_fscore_support

dataset = load_dataset("imdb")
dataset

tokenizer = BertTokenizer.from_pretrained("bert-base-uncased")

def tokenize(batch):
    return tokenizer(batch["text"], padding="max_length", truncation=True, max_length=128)

dataset = dataset.map(tokenize, batched=True)
dataset = dataset.rename_column("label", "labels")
dataset.set_format("torch", columns=["input_ids", "attention_mask", "labels"])

model = BertForSequenceClassification.from_pretrained("bert-base-uncased", num_labels=2)

def compute_metrics(pred):
    labels = pred.label_ids
    preds = np.argmax(pred.predictions, axis=1)
    precision, recall, f1, _ = precision_recall_fscore_support(labels, preds, average="binary")
    acc = accuracy_score(labels, preds)
    return {"accuracy": acc, "f1": f1, "precision": precision, "recall": recall}

from transformers import TrainingArguments, Trainer
from tqdm.auto import tqdm

# Custom blue progress bar style
tqdm.pandas(bar_format="{l_bar}{bar:30}{r_bar}", colour="blue")

training_args = TrainingArguments(
    output_dir="./results",
    learning_rate=2e-5,
    per_device_train_batch_size=8,
    per_device_eval_batch_size=8,
    num_train_epochs=3,   # adjust as needed
    weight_decay=0.01,
    logging_dir="./logs",
    report_to="none"   # ğŸš« disable wandb / tensorboard / mlflow
)

trainer = Trainer(
    model=model,
    args=training_args,
    train_dataset=dataset["train"].shuffle(seed=42).select(range(2000)),
    eval_dataset=dataset["test"].shuffle(seed=42).select(range(500)),
    compute_metrics=compute_metrics
)

trainer.train()

# Manually evaluate after training
results = trainer.evaluate()
print("ğŸ“Š Evaluation Results:", results)

trainer.save_model("bert-sentiment")
tokenizer.save_pretrained("bert-sentiment")

from google.colab import files
import shutil

# Zip the fine-tuned model
shutil.make_archive("bert-sentiment", 'zip', "bert-sentiment")

# Download the zip
files.download("bert-sentiment.zip")

# Upload zip back when needed
!unzip -o bert-sentiment.zip

# ********** To use when runtime is disconnected **********

from google.colab import files
uploaded = files.upload()  # choose bert-sentiment.zip from your PC
!mkdir -p bert-sentiment
!unzip -o bert-sentiment.zip -d bert-sentiment

!ls bert-sentiment

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# from transformers import BertTokenizer, BertForSequenceClassification, pipeline
# import os
# 
# # ----------- Streamlit Page Config -----------
# st.set_page_config(page_title="ğŸ¬ Movie Review Sentiment Analysis", layout="wide")
# 
# # ----------- Model Path Handling -----------
# MODEL_PATH = "./bert-sentiment"  # folder must exist after unzip
# 
# if not os.path.exists(MODEL_PATH) or len(os.listdir(MODEL_PATH)) == 0:
#     st.error("âŒ Model folder 'bert-sentiment' not found or empty. Please train or upload 'bert-sentiment.zip' and unzip first.")
# else:
#     try:
#         tokenizer = BertTokenizer.from_pretrained(MODEL_PATH)
#         model = BertForSequenceClassification.from_pretrained(MODEL_PATH)
#         sentiment_pipeline = pipeline("sentiment-analysis", model=model, tokenizer=tokenizer)
# 
#         # ----------- Custom CSS -----------
#         st.markdown("""
#         <style>
#         /* Background Animation */
#         @keyframes gradient {
#             0% {background-position: 0% 50%;}
#             50% {background-position: 100% 50%;}
#             100% {background-position: 0% 50%;}
#         }
#         .stApp {
#             background: linear-gradient(-45deg, #141E30, #243B55, #232526, #414345);
#             background-size: 400% 400%;
#             animation: gradient 15s ease infinite;
#             color: white;
#         }
#         h1 {
#             text-align: center;
#             font-size: 2.8em;
#             margin-bottom: 0.3em;
#             color: #FFD700;
#             text-shadow: 2px 2px 5px black;
#         }
#         .subtitle {
#             text-align: center;
#             font-size: 1.2em;
#             margin-bottom: 20px;
#             color: #E0E0E0;
#         }
#         textarea {
#             border-radius: 12px !important;
#             border: 2px solid #FFD700 !important;
#             background: rgba(255,255,255,0.1) !important;
#             color: white !important;
#             font-size: 1.1em !important;
#         }
#         .stButton>button {
#             background: linear-gradient(135deg, #FFD700, #FFA500);
#             color: black;
#             font-weight: bold;
#             border-radius: 12px;
#             padding: 10px 20px;
#             transition: 0.3s;
#             border: none;
#         }
#         .stButton>button:hover {
#             background: linear-gradient(135deg, #FFA500, #FF4500);
#             color: white;
#             transform: scale(1.05);
#         }
#         .result-box {
#             background: rgba(0,0,0,0.6);
#             padding: 20px;
#             border-radius: 12px;
#             margin-top: 25px;
#             text-align: center;
#             font-size: 1.3em;
#             box-shadow: 0px 0px 15px rgba(255,215,0,0.5);
#         }
#         .positive {color: #00FF7F; font-weight: bold;}
#         .negative {color: #FF6347; font-weight: bold;}
#         .divider {
#             text-align: center;
#             margin: 20px 0;
#             font-size: 1.5em;
#             color: #FFD700;
#         }
#         </style>
#         """, unsafe_allow_html=True)
# 
#         # ----------- App UI -----------
#         st.title("ğŸ¬ IMDB Movie Review Sentiment Classifier")
#         st.markdown("<p class='subtitle'>Enter a movie review below and discover if itâ€™s a ğŸ‘ Positive hit or a ğŸ‘ Negative flop!</p>", unsafe_allow_html=True)
# 
#         st.markdown("<div class='divider'>ğŸï¸ â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” ğŸï¸</div>", unsafe_allow_html=True)
# 
#         review = st.text_area("âœï¸ Write your movie review:", height=150)
# 
#         if st.button("ğŸ” Analyze Sentiment"):
#             if review.strip() == "":
#                 st.warning("âš ï¸ Please enter a review before analyzing.")
#             else:
#                 with st.spinner("ğŸ¤” Analyzing the review..."):
#                     try:
#                         result = sentiment_pipeline(review)[0]
#                         label = result["label"]
#                         score = result["score"]
# 
#                         # Map HuggingFace labels to human readable
#                         if label == "LABEL_1":
#                             sentiment = "ğŸ‘ Positive"
#                             css_class = "positive"
#                         else:
#                             sentiment = "ğŸ‘ Negative"
#                             css_class = "negative"
# 
#                         st.markdown(f"""
#                         <div class="result-box">
#                             <h3>ğŸ§¾ Sentiment Result:</h3>
#                             <p class="{css_class}">{sentiment}</p>
#                             <p>Confidence: <b>{score:.2f}</b></p>
#                         </div>
#                         """, unsafe_allow_html=True)
#                     except Exception as e:
#                         st.error(f"âš ï¸ Error during analysis: {str(e)}")
#     except Exception as e:
#         st.error(f"âš ï¸ Failed to load model: {str(e)}")
#

!kill -9 $(ps -A | grep ngrok | awk '{print $1}')

# Kill previous streamlit if running
!kill -9 $(lsof -t -i:8501) 2>/dev/null || echo "No previous Streamlit instance"

import time
from pyngrok import ngrok
import subprocess

# ğŸ”‘ Auth token
ngrok.set_auth_token("33pyU8XWfrN8JFX8kwzY8Uf1j7s_612rotnaQX2f58dq3n8Ez")

# Start Streamlit in background (suppress logs so Python can continue)
process = subprocess.Popen(
    ["streamlit", "run", "app.py", "--server.port", "8501", "--server.headless", "true"],
    stdout=subprocess.DEVNULL,
    stderr=subprocess.STDOUT
)

time.sleep(5)  # wait for streamlit to boot

# Start ngrok tunnel
public_url = ngrok.connect(8501)
print("ğŸŒ Your public ngrok URL:", public_url.public_url)

